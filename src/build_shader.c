/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   build_shader.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: alelievr <alelievr@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2017/04/09 19:50:38 by alelievr          #+#    #+#             */
/*   Updated: 2017/04/10 20:54:42 by alelievr         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "shaderpixel.h"
#include <sys/stat.h>
#include <string.h>
#include <unistd.h>

typedef struct	s_line_list
{
	char				*line;
	struct s_line_list	*next;
}				t_line_list;

typedef struct
{
	t_line_list		*begin;
	t_line_list		*function_begin;
	t_line_list		*uniform_begin;
	t_line_list		*main_image_begin;
	t_line_list		*raytrace_lights;
	t_line_list		*scene_begin;
	t_line_list		*scene_end;
}			t_shader_file;

#define MAX_TEXTURES	512

static t_vec4		atlas_bounds[MAX_TEXTURES];

#define NEW_LINE_LIST ({t_line_list *m; if (!(m = (t_line_list *)malloc(sizeof(t_line_list)))) ft_exit("malloc error !"); m->next = NULL; m->line = NULL; m;})
#define LIST_INSERT(l, s) {t_line_list *tmp = NEW_LINE_LIST; tmp->line = s; tmp->next = l->next; l->next = tmp;}
#define LIST_APPEND(l, s) {t_line_list *tmp = NEW_LINE_LIST; tmp->line = s; tmp->next = l->next; l->next = tmp; l = tmp;}

#define ISTYPE(x) (obj->primitive.type == x)
#define ISPRIMITIVE (ISTYPE(SPHERE) || ISTYPE(PLANE) || ISTYPE(CYLINDRE) || ISTYPE(CONE))

static void	init_shader_file(t_shader_file *shader_file)
{
	if (!(shader_file->begin = NEW_LINE_LIST))
		ft_exit("malloc error !");
	LIST_APPEND(shader_file->begin, strdup("#version 330\n/* AutoGenerated shader !* /\n\n/* Main and standard uniforms */\n"));
	LIST_APPEND(shader_file->begin, strdup(fragment_shader_text));
	shader_file->uniform_begin = shader_file->begin;
	shader_file->function_begin = shader_file->begin;
	LIST_APPEND(shader_file->function_begin, strdup("/* Static functions */\n"));
	LIST_APPEND(shader_file->function_begin, strdup(shader_header_text));
	shader_file->main_image_begin = shader_file->function_begin;
	shader_file->scene_begin = shader_file->function_begin;
	LIST_INSERT(shader_file->scene_begin, strdup("/* Generated scene from parser */\n"));
	shader_file->scene_end = shader_file->scene_begin->next;
	LIST_APPEND(shader_file->scene_begin, strdup(scene_start_text));
	LIST_APPEND(shader_file->scene_end, strdup(scene_end_text));
	shader_file->raytrace_lights = shader_file->scene_end;
	LIST_APPEND(shader_file->raytrace_lights, strdup(raytrace_start_text));
	LIST_INSERT(shader_file->raytrace_lights, strdup(raytrace_end_text));
	LIST_APPEND(shader_file->main_image_begin, strdup("\n/* Static MainImage */\n"));
	LIST_APPEND(shader_file->main_image_begin, strdup(main_image_start_text));
	LIST_APPEND(shader_file->uniform_begin, strdup("/* Generated uniforms */\n"));
}

static void	load_essencial_files(t_shader_file *shader_file)
{
	const char * const	*files = (const char * const[]){"shaders/new.glsl", NULL};
	struct stat			st;
	int					fd;
	char				line[0xF000];

	while (*files)
	{
		if ((fd = open(*files, O_RDONLY)) == -1)
			perror("open"), exit(-1);
		fstat(fd, &st);
		if (!S_ISREG(st.st_mode))
			ft_exit("bad file type: %s\n", *files);
		while (gl(line, &fd))
			LIST_APPEND(shader_file->function_begin, strdup(line));
		files++;
	}
}

#define MAX_SHADER_FILE_SIZE	0xF000
static char	*concat_line_list(t_shader_file *shader_file)
{
	static char		buff[MAX_SHADER_FILE_SIZE + 1];
	t_line_list		*line = shader_file->begin;
	t_line_list		*prev;
	int				index;

	index = 0;
	while (line)
	{
		if (line->line == NULL)
		{
			line = line->next;
			continue ;
		}
		strcpy(buff + index, line->line);
		index += strlen(line->line);
		free(line->line);
		buff[index++] = '\n';
		prev = line;
		line = line->next;
		free(prev);
	}
	write(1, buff, index);
	return buff;
}

static void		format_name(char *name)
{
	while (*name)
	{
		if (*name == ':')
		{
			*name = 0;
			break ;
		}
		if (!isalnum(*name))
			*name = '_';
		name++;
	}
}

static char		*generate_material_line(t_object *obj)
{
	static char		line[0xF00];

	sprintf(line, "vec4(0, 0, 1, 1), vec4(0, 0, 1, 1), vec4(0, 0, 1, 1), vec4(0, 0, 1, 1), vec4(0, 0, 1, 1), vec4(0, 0, 1, 1), vec4(0, 0, 1, 1)");
	return (line);
}

static char		*generate_scene_line(t_object *obj)
{
	static char		line[0xF00];

	if (ISTYPE(SPHERE))
		sprintf(line, "\tsphere(%s_position, %f, vec4(0), Material(%s), r, hit);", obj->name, obj->primitive.radius, generate_material_line(obj));
	else if (ISTYPE(PLANE))
		sprintf(line, "\tplane(%s_rotation, %s_position, vec3(0, 1, 0), Material(%s), r, hit);", obj->name, obj->name, generate_material_line(obj));
	else if (ISTYPE(CYLINDRE))
		sprintf(line, "\tcyl(%s_position, %s_rotation, Material(%s), r, hit);", obj->name, obj->name, generate_material_line(obj));
	else if (ISTYPE(CONE))
		sprintf(line, "\tsphere(%s_position, %s_rotation, Material(%s), r, hit);", obj->name, obj->name, generate_material_line(obj));
	else
		return (NULL);
	return (strdup(line));
}

static void		append_uniforms(t_shader_file *shader_file, t_object *obj)
{
	static char		line[0xF000];

	if (ISPRIMITIVE)
	{
		sprintf(line, "uniform vec3 %s_position;", obj->name);
		LIST_APPEND(shader_file->uniform_begin, strdup(line));
		sprintf(line, "uniform vec3 %s_rotation;", obj->name);
		LIST_APPEND(shader_file->uniform_begin, strdup(line));
	}
	else if (!ISTYPE(CAMERA)) //lighs
	{
		sprintf(line, "color += calc_light(vec3(%f, %f, %f), r, h);", obj->transform.position.x, obj->transform.position.y, obj->transform.position.z);
		LIST_APPEND(shader_file->raytrace_lights, strdup(line));
	}
}

static void		tree_march(t_shader_file *shader_file, t_scene *scene)
{
	int			obj_count = 0;
	t_object	*obj;

	obj = scene->root_view;
	while (obj_count < scene->nb_object)
	{
		format_name(obj->name);
		append_uniforms(shader_file, obj);
		LIST_APPEND(shader_file->scene_begin, generate_scene_line(obj));

		if (obj->children)
			obj = obj->children;
		else if (obj->brother_of_children)
			obj = obj->brother_of_children;
		else
			obj = obj->parent->brother_of_children;
		obj_count++;
	}
}

static void		load_atlas(t_shader_file *shader_file, t_scene *scene)
{
	int			obj_count = 0;
	t_object	*obj;

	obj = scene->root_view;
	while (obj_count < scene->nb_object)
	{
		format_name(obj->name);
		//TODO: check if material contains a texture and store its size.

		if (obj->children)
			obj = obj->children;
		else if (obj->brother_of_children)
			obj = obj->brother_of_children;
		else
			obj = obj->parent->brother_of_children;
		obj_count++;
	}
}

char		*build_shader(t_scene *root)
{
	t_shader_file		shader_file;

	init_shader_file(&shader_file);
	load_essencial_files(&shader_file);

	load_atlas(&shader_file, root);

	tree_march(&shader_file, root);

	return concat_line_list(&shader_file);
}
