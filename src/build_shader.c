/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   build_shader.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: avially <avially@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2017/04/09 19:50:38 by alelievr          #+#    #+#             */
/*   Updated: 2017/04/21 14:38:53 by avially          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "shaderpixel.h"
#include <sys/stat.h>
#include <string.h>
#include <unistd.h>

typedef struct	s_line_list
{
	char				*line;
	struct s_line_list	*next;
}				t_line_list;

typedef struct
{
	t_line_list		*begin;
	t_line_list		*function_begin;
	t_line_list		*uniform_begin;
	t_line_list		*main_image_begin;
	t_line_list		*raytrace_lights;
	t_line_list		*scene_begin;
	t_line_list		*scene_end;
}			t_shader_file;

typedef struct		s_atlas
{
	unsigned char	*data;
	GLuint			id;
	int				width;
	int				height;
}					t_atlas;

#define MAX_TEXTURES	512

#define NEW_LINE_LIST ({t_line_list *m; if (!(m = (t_line_list *)malloc(sizeof(t_line_list)))) ft_exit("malloc error !"); m->next = NULL; m->line = NULL; m;})
#define LIST_INSERT(l, s) {t_line_list *tmp = NEW_LINE_LIST; tmp->line = s; tmp->next = l->next; l->next = tmp;}
#define LIST_APPEND(l, s) {t_line_list *tmp = NEW_LINE_LIST; tmp->line = s; tmp->next = l->next; l->next = tmp; l = tmp;}

#define ISTYPE(x) (obj->primitive.type == x + 1)
#define ISPRIMITIVE (ISTYPE(SPHERE) || ISTYPE(PLANE) || ISTYPE(CYLINDRE) || ISTYPE(CONE) || ISTYPE(CUBE))
#define ISLIGHT (ISTYPE(POINT_LIGHT) || ISTYPE(DIRECTIONAL_LIGHT) || ISTYPE(SPOT_LIGHT))

#define MAX(x, y) ((x > y) ? x : y)

static void	init_shader_file(t_shader_file *shader_file)
{
	if (!(shader_file->begin = NEW_LINE_LIST))
		ft_exit("malloc error !");
	LIST_APPEND(shader_file->begin, strdup("#version 330\n/* AutoGenerated shader !* /\n\n/* Main and standard uniforms */\n"));
	LIST_APPEND(shader_file->begin, strdup(fragment_shader_text));
	shader_file->uniform_begin = shader_file->begin;
	shader_file->function_begin = shader_file->begin;
	LIST_APPEND(shader_file->function_begin, strdup("/* Static functions */\n"));
	LIST_APPEND(shader_file->function_begin, strdup(shader_header_text));
	shader_file->main_image_begin = shader_file->function_begin;
	shader_file->scene_begin = shader_file->function_begin;
	LIST_INSERT(shader_file->scene_begin, strdup("/* Generated scene from parser */\n"));
	shader_file->scene_end = shader_file->scene_begin->next;
	LIST_APPEND(shader_file->scene_begin, strdup(scene_start_text));
	LIST_APPEND(shader_file->scene_end, strdup(scene_end_text));
	shader_file->raytrace_lights = shader_file->scene_end;
	LIST_APPEND(shader_file->raytrace_lights, strdup(raytrace_start_text));
	LIST_INSERT(shader_file->raytrace_lights, strdup(raytrace_end_text));
	LIST_APPEND(shader_file->main_image_begin, strdup("\n/* Static MainImage */\n"));
	LIST_APPEND(shader_file->main_image_begin, strdup(main_image_start_text));
	LIST_APPEND(shader_file->uniform_begin, strdup("/* Generated uniforms */\n"));
}

static void	load_essencial_files(t_shader_file *shader_file)
{
	const char * const	*files = (const char * const[]){"shaders/tri/scene.glsl","shaders/tri/plane.glsl","shaders/tri/sphere.glsl","shaders/tri/cylinder.glsl","shaders/tri/cone.glsl","shaders/tri/cube.glsl","shaders/tri/light1.glsl",NULL};
	int					fd;
	char				line[0xF000];

	while (*files)
	{
		if ((fd = open(*files, O_RDONLY)) == -1)
			perror("open"), exit(-1);
		if (!file_is_regular(fd))
			ft_exit("bad file type: %s\n", *files);
		while (gl(line, &fd))
			LIST_APPEND(shader_file->function_begin, strdup(line));
		files++;
	}
}

#define MAX_SHADER_FILE_SIZE	0xF000
static char	*concat_line_list(t_shader_file *shader_file)
{
	static char		buff[MAX_SHADER_FILE_SIZE + 1];
	t_line_list		*line = shader_file->begin;
	t_line_list		*prev;
	int				index;

	index = 0;
	while (line)
	{
		if (line->line == NULL)
		{
			line = line->next;
			continue ;
		}
		strcpy(buff + index, line->line);
		index += strlen(line->line);
		free(line->line);
		buff[index++] = '\n';
		prev = line;
		line = line->next;
		free(prev);
	}
	write(1, buff, index);
	return buff;
}

static void		format_name(char *name)
{
	while (*name)
	{
		if (*name == ':')
		{
			*name = 0;
			break ;
		}
		if (!isalnum(*name))
			*name = '_';
		name++;
	}
}

#define GET_UVS(img) img.atlas_uv.x, img.atlas_uv.y, img.atlas_uv.z, img.atlas_uv.w
static char		*generate_material_line(t_material *mat)
{
	static char		line[0xF00];

	sprintf(line, "vec4(%f, %f, %f, %f), vec4(%f, %f, %f, %f), vec4(%f, %f, %f, %f), vec4(%f, %f, %f, %f), vec4(%f, %f, %f, %f), vec4(%f, %f, %f, %f), vec4(%f, %f, %f, %f)",
			GET_UVS(mat->texture),
			GET_UVS(mat->emission_map),
			GET_UVS(mat->transparency_map),
			GET_UVS(mat->specular_map),
			GET_UVS(mat->reflection_map),
			GET_UVS(mat->refraction_map),
			GET_UVS(mat->bumpmap));
	return (line);
}

static char		*generate_scene_line(t_object *obj)
{
	static char		line[0xF00];

	if (ISTYPE(SPHERE))
		sprintf(line, "\tsphere(%s_position, %f, Material(%s), r, hit);", obj->name, obj->primitive.radius, generate_material_line(&obj->material));
	else if (ISTYPE(PLANE))
		sprintf(line, "\tplane(%s_rotation, %s_position, 0, Material(%s), r, hit);", obj->name, obj->name, generate_material_line(&obj->material));
	else if (ISTYPE(CYLINDRE))
		sprintf(line, "\tcyl(%s_position, %s_rotation, %f, Material(%s), r, hit);", obj->name, obj->name, obj->primitive.angle, generate_material_line(&obj->material));
	else if (ISTYPE(CONE))
		sprintf(line, "\tcone(%s_position, %s_rotation, %f, Material(%s), r, hit);", obj->name, obj->name, obj->primitive.angle, generate_material_line(&obj->material));
	else if (ISTYPE(CUBE))
		sprintf(line, "\tcube(%s_position, %s_rotation, %f, Material(%s), r, hit);", obj->name, obj->name, obj->primitive.height, generate_material_line(&obj->material));
	else
		return (NULL);
	return (strdup(line));
}

static void		append_uniforms(t_shader_file *shader_file, t_object *obj)
{
	static char		line[0xF000];

	if (ISPRIMITIVE)
	{
		sprintf(line, "uniform vec3 %s_position = vec3(%f, %f, %f);", obj->name, obj->transform.position.x, obj->transform.position.y, obj->transform.position.z);
		LIST_APPEND(shader_file->uniform_begin, strdup(line));
		sprintf(line, "uniform vec3 %s_rotation = vec3(%f, %f, %f);", obj->name, obj->transform.rotation.x, obj->transform.rotation.y, obj->transform.rotation.z);
		LIST_APPEND(shader_file->uniform_begin, strdup(line));
	}
	else if (ISLIGHT) //lighs
	{
		sprintf(line, "\tcolor += calc_light(vec3(%f, %f, %f), r, h);", obj->transform.position.x, obj->transform.position.y, obj->transform.position.z);
		LIST_APPEND(shader_file->raytrace_lights, strdup(line));
	}
	else if(ISTYPE(CAMERA))
	{
			move.x = obj->transform.position.x;
			move.y = obj->transform.position.y;
			move.z = obj->transform.position.z;
			fov = obj->camera.fov;
	}
}

static void		tree_march(t_shader_file *shader_file, t_object *obj)
{
	while (obj)
	{
		format_name(obj->name);
		append_uniforms(shader_file, obj);
		LIST_APPEND(shader_file->scene_begin, generate_scene_line(obj));

		if (obj->children)
			tree_march(shader_file, obj->children);
		obj = obj->brother_of_children;
	}
}

static unsigned char	*generate_image_from_data(float data, int *width, int *height) __attribute__((overloadable))
{
	unsigned char	*ret = (unsigned char *)malloc(sizeof(unsigned char) * 4);

	printf("generated 1px texture from float: %f\n", data);
	memset(ret, (char)(data * 255), 4);
	*width = 1;
	*height = 1;
	return ret;
}

static unsigned char	*generate_image_from_data(t_vec3 data, int *width, int *height) __attribute__((overloadable))
{
	unsigned char	*ret = (unsigned char *)malloc(sizeof(unsigned char) * 4);

	printf("generated 1px texture from color: %f/%f/%f\n", data.x, data.y, data.z);
	ret[0] = data.x;
	ret[1] = data.y;
	ret[2] = data.z;
	ret[3] = 255;
	*width = 1;
	*height = 1;
	return ret;
}

static char		*build_path(char *dir, char *file)
{
	static char		path[1024];
	char			*f;

	//trim file:
	f = file + strlen(file) - 1;
	while (isspace(*f))
		*f-- = 0;
	f = file;
	while (isspace(*f))
		f++;
	strcpy(path, dir);
	strcat(path, file);
	return path;
}

static unsigned char	*load_image(char *path, int *width, int *height, int *channels)
{
	return SOIL_load_image(path, width, height, channels, SOIL_LOAD_AUTO);
}

#define LOAD_TEXTURE(m, p, o) printf("texture: %s\n", #p); if (m->has_##p && m->p.file[0]) m->p.data = load_image(build_path(scene_directory, m->p.file), &m->p.width, &m->p.height, &m->p.channels); else m->p.data = generate_image_from_data(m->o, &m->p.width, &m->p.height);
#define LOAD_TEXTURE_ATLAS(m, p, o, aw, ah) LOAD_TEXTURE(m, p, o); *aw += m->p.width; *ah = MAX(*ah, m->p.height);

static void		load_textures_if_exists(t_material *m, char *scene_directory, int *atlas_width, int *atlas_height)
{
	LOAD_TEXTURE_ATLAS(m, texture, color, atlas_width, atlas_height);
	LOAD_TEXTURE_ATLAS(m, bumpmap, bump, atlas_width, atlas_height);
	LOAD_TEXTURE_ATLAS(m, emission_map, emission_color, atlas_width, atlas_height);
	LOAD_TEXTURE_ATLAS(m, highlight_map, highlight_color, atlas_width, atlas_height);
	LOAD_TEXTURE_ATLAS(m, reflection_map, reflection, atlas_width, atlas_height);
	LOAD_TEXTURE_ATLAS(m, refraction_map, refraction, atlas_width, atlas_height);
	LOAD_TEXTURE_ATLAS(m, transparency_map, transparency, atlas_width, atlas_height);
	LOAD_TEXTURE_ATLAS(m, specular_map, specular, atlas_width, atlas_height);
}

static void		load_atlas(t_object *obj, char *scene_directory, int *atlas_width, int *atlas_height)
{
	while (obj)
	{
		format_name(obj->name);

		printf("\033[38;5;42mobj: %s\033[0m\n", obj->name);
		load_textures_if_exists(&obj->material, scene_directory, atlas_width, atlas_height);

		if (obj->children)
			load_atlas(obj->children, scene_directory, atlas_width, atlas_height);
		obj = obj->brother_of_children;
	}
}

static void		add_subimage(t_atlas *atlas, int offset_x, int offset_y, t_image *img)
{
	unsigned char	*begin;
	unsigned char	*imgdata;
	int				x, y;

	imgdata = img->data;
	y = 0;
	//printf("writing img at: %i/%i wh: %i/%i in atlas of size: %i/%i\n", offset_x, offset_y, img->width, img->height, atlas->width, atlas->height);
	while (y < img->height)
	{
		begin = atlas->data + (offset_x * 4) + ((offset_y + y) * atlas->width * 4);
		x = 0;
		while (x < img->width)
		{
			*(unsigned int *)begin = *(unsigned int *)imgdata;
			begin += 4;
			imgdata += img->channels;
			x++;
		}
		y++;
	}
}

#define COMPUTE_OFFSET(m, p) (t_vec4){(float)*offset_x / (float)atlas->width, (float)*offset_y / (float)atlas->height, (float)(*offset_x + m->p.width) / (float)atlas->width, (float)(*offset_y + m->p.height) / (float)atlas->height}
#define ADD_TEXTURE_ATLAS(m, p) add_subimage(atlas, *offset_x, *offset_y, &m->p); m->p.atlas_uv = COMPUTE_OFFSET(m, p); *offset_x += m->p.width; printf("uv: %f/%f - %f/%f\n", m->p.atlas_uv.x, m->p.atlas_uv.y, m->p.atlas_uv.z, m->p.atlas_uv.w)

static void		add_object_textures_to_atlas(t_material *mat, t_atlas *atlas, int *offset_x, int *offset_y)
{
	ADD_TEXTURE_ATLAS(mat, texture);
	ADD_TEXTURE_ATLAS(mat, bumpmap);
	ADD_TEXTURE_ATLAS(mat, emission_map);
	ADD_TEXTURE_ATLAS(mat, highlight_map);
	ADD_TEXTURE_ATLAS(mat, reflection_map);
	ADD_TEXTURE_ATLAS(mat, refraction_map);
	ADD_TEXTURE_ATLAS(mat, transparency_map);
	ADD_TEXTURE_ATLAS(mat, specular_map);
}

static unsigned int	build_atlas(t_object *obj, int atlas_width, int atlas_height)
{
	t_atlas			atlas;
	int				offset_x = 0;
	int				offset_y = 0;

	atlas.width = atlas_width;
	atlas.height = atlas_height;
	atlas.data = (unsigned char *)malloc(sizeof(int) * atlas_width * atlas_height);
	memset(atlas.data, 0, sizeof(int) * atlas_width * atlas_height);

	glGenTextures(1, &atlas.id);
	while (obj)
	{
		add_object_textures_to_atlas(&obj->material, &atlas, &offset_x, &offset_y);

		if (obj->children)
			build_atlas(obj->children, atlas_width, atlas_height);
		obj = obj->brother_of_children;
	}
	glBindTexture(GL_TEXTURE_2D, atlas.id);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);
	glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, atlas_width, atlas_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, atlas.data);
	return atlas.id;
}

char		*build_shader(t_scene *root, char *scene_directory, int *atlas_id)
{
	t_shader_file		shader_file;
	int					atlas_width = 0;
	int					atlas_height = 0;

	init_shader_file(&shader_file);
	load_essencial_files(&shader_file);

	load_atlas(root->root_view, scene_directory, &atlas_width, &atlas_height);
	*atlas_id = build_atlas(root->root_view, atlas_width, atlas_height);

	tree_march(&shader_file, root->root_view);

	return concat_line_list(&shader_file);
}
